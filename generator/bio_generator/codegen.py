"""C++17 code generation using Jinja2 templates."""

from __future__ import annotations

import pathlib
import re
from typing import Any, Dict, List, Tuple

from jinja2 import Environment, BaseLoader

from .types import (
    BITFIELD_TYPES,
    BYTE_ORDERS,
    PRIMITIVES,
    BitDef,
    EnumDef,
    FieldDef,
    ProtocolDef,
    StructDef,
    TypeKind,
)


# ---------------------------------------------------------------------------
# Jinja2 helpers exposed as template filters / globals
# ---------------------------------------------------------------------------

def _cpp_type(type_name: str, proto: ProtocolDef) -> str:
    """Map a YAML type name to its C++ type string."""
    if type_name in PRIMITIVES:
        return PRIMITIVES[type_name].cpp_type
    if type_name in proto.enum_map:
        return type_name
    if type_name in proto.struct_map:
        return type_name
    return type_name


def _hex_literal(value: int) -> str:
    """Format an integer as a C++ hex literal."""
    if value < 0:
        return str(value)
    return f"0x{value:X}"


def _format_expected(value: Any) -> str:
    """Format an expected-value constant for C++."""
    if isinstance(value, int):
        return _hex_literal(value)
    return str(value)


def _bitfield_member_type(b: BitDef, proto: ProtocolDef | None = None) -> str:
    """Return the C++ type for an individual bitfield member.

    If the bit-slice references an enum (via ``enum_type``), return the enum
    name.  Otherwise choose the smallest unsigned type that fits *width*
    (``bool`` for 1-bit fields).
    """
    if b.enum_type and proto and b.enum_type in proto.enum_map:
        return b.enum_type
    if b.width == 1:
        return "bool"
    if b.width <= 8:
        return "uint8_t"
    if b.width <= 16:
        return "uint16_t"
    return "uint32_t"


# ---------------------------------------------------------------------------
# Template strings
# ---------------------------------------------------------------------------

IO_TEMPLATE = r"""// =============================================================================
// Auto-generated by bio-gen — binary I/O primitives for {{ namespace }}
// DO NOT EDIT — changes will be overwritten.
// =============================================================================

#ifndef {{ io_guard }}
#define {{ io_guard }}

#include <cstddef>
#include <cstdint>
#include <cstring>
{% if namespace %}
namespace {{ namespace }} {
{% endif %}
/// Result type indicating success or failure of a read/write operation.
struct [[nodiscard]] Status {
    bool ok;

    constexpr explicit operator bool() const { return ok; }
    static constexpr Status Ok() { return {true}; }
    static constexpr Status OutOfRange() { return {false}; }
};

struct LittleEndianCodec {
    static inline uint16_t LoadU16(const uint8_t* p) {
        return static_cast<uint16_t>(static_cast<uint16_t>(p[0]) |
                                     (static_cast<uint16_t>(p[1]) << 8));
    }
    static inline uint32_t LoadU32(const uint8_t* p) {
        return (static_cast<uint32_t>(p[0]) << 0) |
               (static_cast<uint32_t>(p[1]) << 8) |
               (static_cast<uint32_t>(p[2]) << 16) |
               (static_cast<uint32_t>(p[3]) << 24);
    }
    static inline uint64_t LoadU64(const uint8_t* p) {
        return (static_cast<uint64_t>(p[0]) << 0) |
               (static_cast<uint64_t>(p[1]) << 8) |
               (static_cast<uint64_t>(p[2]) << 16) |
               (static_cast<uint64_t>(p[3]) << 24) |
               (static_cast<uint64_t>(p[4]) << 32) |
               (static_cast<uint64_t>(p[5]) << 40) |
               (static_cast<uint64_t>(p[6]) << 48) |
               (static_cast<uint64_t>(p[7]) << 56);
    }
    static inline void StoreU16(uint8_t* p, uint16_t v) {
        p[0] = static_cast<uint8_t>((v >> 0) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
    }
    static inline void StoreU32(uint8_t* p, uint32_t v) {
        p[0] = static_cast<uint8_t>((v >> 0) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
        p[2] = static_cast<uint8_t>((v >> 16) & 0xFFu);
        p[3] = static_cast<uint8_t>((v >> 24) & 0xFFu);
    }
    static inline void StoreU64(uint8_t* p, uint64_t v) {
        p[0] = static_cast<uint8_t>((v >> 0) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 8) & 0xFFu);
        p[2] = static_cast<uint8_t>((v >> 16) & 0xFFu);
        p[3] = static_cast<uint8_t>((v >> 24) & 0xFFu);
        p[4] = static_cast<uint8_t>((v >> 32) & 0xFFu);
        p[5] = static_cast<uint8_t>((v >> 40) & 0xFFu);
        p[6] = static_cast<uint8_t>((v >> 48) & 0xFFu);
        p[7] = static_cast<uint8_t>((v >> 56) & 0xFFu);
    }
};

struct BigEndianCodec {
    static inline uint16_t LoadU16(const uint8_t* p) {
        return static_cast<uint16_t>((static_cast<uint16_t>(p[0]) << 8) |
                                     static_cast<uint16_t>(p[1]));
    }
    static inline uint32_t LoadU32(const uint8_t* p) {
        return (static_cast<uint32_t>(p[0]) << 24) |
               (static_cast<uint32_t>(p[1]) << 16) |
               (static_cast<uint32_t>(p[2]) << 8) |
               (static_cast<uint32_t>(p[3]) << 0);
    }
    static inline uint64_t LoadU64(const uint8_t* p) {
        return (static_cast<uint64_t>(p[0]) << 56) |
               (static_cast<uint64_t>(p[1]) << 48) |
               (static_cast<uint64_t>(p[2]) << 40) |
               (static_cast<uint64_t>(p[3]) << 32) |
               (static_cast<uint64_t>(p[4]) << 24) |
               (static_cast<uint64_t>(p[5]) << 16) |
               (static_cast<uint64_t>(p[6]) << 8) |
               (static_cast<uint64_t>(p[7]) << 0);
    }
    static inline void StoreU16(uint8_t* p, uint16_t v) {
        p[0] = static_cast<uint8_t>((v >> 8) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 0) & 0xFFu);
    }
    static inline void StoreU32(uint8_t* p, uint32_t v) {
        p[0] = static_cast<uint8_t>((v >> 24) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 16) & 0xFFu);
        p[2] = static_cast<uint8_t>((v >> 8) & 0xFFu);
        p[3] = static_cast<uint8_t>((v >> 0) & 0xFFu);
    }
    static inline void StoreU64(uint8_t* p, uint64_t v) {
        p[0] = static_cast<uint8_t>((v >> 56) & 0xFFu);
        p[1] = static_cast<uint8_t>((v >> 48) & 0xFFu);
        p[2] = static_cast<uint8_t>((v >> 40) & 0xFFu);
        p[3] = static_cast<uint8_t>((v >> 32) & 0xFFu);
        p[4] = static_cast<uint8_t>((v >> 24) & 0xFFu);
        p[5] = static_cast<uint8_t>((v >> 16) & 0xFFu);
        p[6] = static_cast<uint8_t>((v >> 8) & 0xFFu);
        p[7] = static_cast<uint8_t>((v >> 0) & 0xFFu);
    }
};

/// Byte reader that deserialises from a flat buffer.
template <typename Codec>
class ByteReaderT {
public:
    ByteReaderT(const void* data, size_t size)
        : p_(static_cast<const uint8_t*>(data)), n_(size), size_(size) {}

    size_t remaining() const { return n_; }
    size_t position() const { return size_ - n_; }

    Status read_u8(uint8_t& out) {
        if (1 > n_) return Status::OutOfRange();
        out = *p_++;
        --n_;
        return Status::Ok();
    }
    Status read_u16(uint16_t& out) {
        if (sizeof(uint16_t) > n_) return Status::OutOfRange();
        out = Codec::LoadU16(p_);
        p_ += sizeof(uint16_t);
        n_ -= sizeof(uint16_t);
        return Status::Ok();
    }
    Status read_u32(uint32_t& out) {
        if (sizeof(uint32_t) > n_) return Status::OutOfRange();
        out = Codec::LoadU32(p_);
        p_ += sizeof(uint32_t);
        n_ -= sizeof(uint32_t);
        return Status::Ok();
    }
    Status read_u64(uint64_t& out) {
        if (sizeof(uint64_t) > n_) return Status::OutOfRange();
        out = Codec::LoadU64(p_);
        p_ += sizeof(uint64_t);
        n_ -= sizeof(uint64_t);
        return Status::Ok();
    }
    Status read_i8(int8_t& out) {
        uint8_t bits = 0;
        if (!read_u8(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_i16(int16_t& out) {
        uint16_t bits = 0;
        if (!read_u16(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_i32(int32_t& out) {
        uint32_t bits = 0;
        if (!read_u32(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_i64(int64_t& out) {
        uint64_t bits = 0;
        if (!read_u64(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_f32(float& out) {
        static_assert(sizeof(float) == 4, "float must be 32-bit");
        uint32_t bits = 0;
        if (!read_u32(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_f64(double& out) {
        static_assert(sizeof(double) == 8, "double must be 64-bit");
        uint64_t bits = 0;
        if (!read_u64(bits)) return Status::OutOfRange();
        std::memcpy(&out, &bits, sizeof(bits));
        return Status::Ok();
    }
    Status read_bytes(void* out, size_t len) {
        if (len > n_) return Status::OutOfRange();
        std::memcpy(out, p_, len);
        p_ += len;
        n_ -= len;
        return Status::Ok();
    }
    Status skip(size_t len) {
        if (len > n_) return Status::OutOfRange();
        p_ += len;
        n_ -= len;
        return Status::Ok();
    }

private:
    const uint8_t* p_;
    size_t n_;
    size_t size_;
};

/// Byte writer that serializes primitives into a fixed-size buffer.
template <typename Codec>
class ByteWriterT {
public:
    ByteWriterT(void* data, size_t size)
        : p_(static_cast<uint8_t*>(data)), n_(size), size_(size) {}

    size_t remaining() const { return n_; }
    size_t position() const { return size_ - n_; }

    Status write_u8(uint8_t v) {
        if (1 > n_) return Status::OutOfRange();
        *p_++ = v;
        --n_;
        return Status::Ok();
    }
    Status write_u16(uint16_t v) {
        if (sizeof(uint16_t) > n_) return Status::OutOfRange();
        Codec::StoreU16(p_, v);
        p_ += sizeof(uint16_t);
        n_ -= sizeof(uint16_t);
        return Status::Ok();
    }
    Status write_u32(uint32_t v) {
        if (sizeof(uint32_t) > n_) return Status::OutOfRange();
        Codec::StoreU32(p_, v);
        p_ += sizeof(uint32_t);
        n_ -= sizeof(uint32_t);
        return Status::Ok();
    }
    Status write_u64(uint64_t v) {
        if (sizeof(uint64_t) > n_) return Status::OutOfRange();
        Codec::StoreU64(p_, v);
        p_ += sizeof(uint64_t);
        n_ -= sizeof(uint64_t);
        return Status::Ok();
    }
    Status write_i8(int8_t v) {
        uint8_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u8(bits);
    }
    Status write_i16(int16_t v) {
        uint16_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u16(bits);
    }
    Status write_i32(int32_t v) {
        uint32_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u32(bits);
    }
    Status write_i64(int64_t v) {
        uint64_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u64(bits);
    }
    Status write_f32(float v) {
        static_assert(sizeof(float) == 4, "float must be 32-bit");
        uint32_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u32(bits);
    }
    Status write_f64(double v) {
        static_assert(sizeof(double) == 8, "double must be 64-bit");
        uint64_t bits = 0;
        std::memcpy(&bits, &v, sizeof(bits));
        return write_u64(bits);
    }
    Status write_bytes(const void* in, size_t len) {
        if (len > n_) return Status::OutOfRange();
        std::memcpy(p_, in, len);
        p_ += len;
        n_ -= len;
        return Status::Ok();
    }
    Status skip(size_t len) {
        if (len > n_) return Status::OutOfRange();
        p_ += len;
        n_ -= len;
        return Status::Ok();
    }

private:
    uint8_t* p_;
    size_t n_;
    size_t size_;
};

using LEReader = ByteReaderT<LittleEndianCodec>;
using BEReader = ByteReaderT<BigEndianCodec>;
using LEWriter = ByteWriterT<LittleEndianCodec>;
using BEWriter = ByteWriterT<BigEndianCodec>;
{% if namespace %}

}  // namespace {{ namespace }}
{%- endif %}

#endif  // {{ io_guard }}
"""

HEADER_TEMPLATE = r"""// =============================================================================
// Auto-generated by bio-gen from {{ source_file }}
// DO NOT EDIT — changes will be overwritten.
// =============================================================================

#ifndef {{ guard }}
#define {{ guard }}

#include <array>
#include <cstddef>
#include <cstdint>
#include <cstring>

#include "{{ io_include }}"
{%- for inc in proto.includes %}
#include "{{ inc }}"
{%- endfor %}
{% if proto.namespace %}
namespace {{ proto.namespace }} {
{% endif %}
// ---------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------
{%- for s in proto.structs %}
struct {{ s.name }};
{%- endfor %}

// ---------------------------------------------------------------------------
// Enumerations
// ---------------------------------------------------------------------------
{% for enum in proto.enums %}
{%- if enum.description %}
/// {{ enum.description }}
{%- endif %}
enum class {{ enum.name }} : {{ enum.cpp_underlying }} {
{%- for v in enum.values %}
{%- if v.description %}
    /// {{ v.description }}
{%- endif %}
    {{ v.name }} = {{ hex_literal(v.value) }},
{%- endfor %}
};
{% endfor %}

// ---------------------------------------------------------------------------
// Structs
// ---------------------------------------------------------------------------
{% for s in proto.structs %}
{%- if s.description %}
/// {{ s.description }}
{%- endif %}
struct {{ s.name }} {
{%- for f in s.fields %}
{%- if f.kind == TypeKind.PADDING %}
    // {{ f.name }}: {{ f.pad_size }} byte(s) padding (not stored)
{%- elif f.kind == TypeKind.BITFIELD %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
{%- for b in f.bits %}
{%- if b.description %}
    /// {{ b.description }}
{%- endif %}
    {{ bitfield_member_type(b, proto) }} {{ b.name }}{};
{%- endfor %}
{%- elif f.kind == TypeKind.BYTES %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<uint8_t, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.STRING %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<char, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.ARRAY %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<{{ cpp_type(f.element_type, proto) }}, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.ENUM %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ f.type }} {{ f.name }}{};
{%- elif f.kind == TypeKind.STRUCT %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ f.type }} {{ f.name }}{};
{%- else %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ cpp_type(f.type, proto) }} {{ f.name }}{};
{%- endif %}
{%- endfor %}

    /// Parse this struct from a binary reader.
    /// @return Status::Ok() on success.
    Status parse({{ proto.reader_alias }}& reader) {
        Status s = Status::Ok();
{% for f in s.fields %}
{{ render_parse_field(f, proto, s) }}
{% endfor %}
        return Status::Ok();
    }

    /// Serialize this struct into a binary writer.
    /// @return Status::Ok() on success.
    Status serialize({{ proto.writer_alias }}& writer) const {
        Status s = Status::Ok();
{% for f in s.fields %}
{{ render_serialize_field(f, proto, s) }}
{% endfor %}
        return Status::Ok();
    }
};
{% endfor %}
{%- if proto.namespace %}

}  // namespace {{ proto.namespace }}
{%- endif %}

#endif  // {{ guard }}
"""


# ---------------------------------------------------------------------------
# Field-level code-generation helpers
# ---------------------------------------------------------------------------

def _indent(code: str, level: int = 2) -> str:
    """Indent every line of *code* by *level* groups of 4 spaces."""
    prefix = "    " * level
    lines = code.rstrip("\n").split("\n")
    return "\n".join(prefix + line if line.strip() else "" for line in lines)


def _enum_switch(target: str, raw_expr: str, enum_def: EnumDef) -> str:
    """Generate a switch statement that safely converts a raw integer to an enum.

    Uses the first declared value as the ``default`` to avoid UB from
    ``static_cast`` with an out-of-range value.
    """
    lines = [f"switch ({raw_expr}) {{"]
    for v in enum_def.values:
        lines.append(
            f"    case {_hex_literal(v.value)}: "
            f"{target} = {enum_def.name}::{v.name}; break;"
        )
    default_val = enum_def.values[0]
    lines.append(
        f"    default: {target} = {enum_def.name}::{default_val.name}; break;"
    )
    lines.append("}")
    return "\n".join(lines)


def _wrap_condition(code: str, condition: str | None) -> str:
    if condition:
        inner = "\n".join("    " + line for line in code.split("\n"))
        return f"if ({condition}) {{\n{inner}\n}}"
    return code


def render_parse_field(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    """Return indented C++ code to parse one field."""
    code = _render_parse_field_inner(f, proto, struct)
    code = _wrap_condition(code, f.condition)
    return _indent(code)


def _render_parse_field_inner(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    if f.kind == TypeKind.PADDING:
        return f"s = reader.skip({f.pad_size});\nif (!s) return s;"

    if f.kind == TypeKind.PRIMITIVE:
        prim = PRIMITIVES[f.type]
        lines = [
            f"s = reader.{prim.read_method}({f.name});",
            "if (!s) return s;",
        ]
        if f.expected is not None:
            lines.append(
                f"if ({f.name} != {_format_expected(f.expected)}) "
                f"return Status::OutOfRange();"
            )
        return "\n".join(lines)

    if f.kind == TypeKind.ENUM:
        enum_def = proto.enum_map[f.type]
        prim = PRIMITIVES[enum_def.underlying_type]
        tmp = f"_{f.name}_raw"
        lines = [
            f"{prim.cpp_type} {tmp}{{}};",
            f"s = reader.{prim.read_method}({tmp});",
            "if (!s) return s;",
        ]
        lines.append(_enum_switch(f.name, tmp, enum_def))
        if f.expected is not None:
            lines.append(
                f"if ({tmp} != {_format_expected(f.expected)}) "
                f"return Status::OutOfRange();"
            )
        return "\n".join(lines)

    if f.kind == TypeKind.STRUCT:
        return f"s = {f.name}.parse(reader);\nif (!s) return s;"

    if f.kind == TypeKind.BITFIELD:
        prim = BITFIELD_TYPES[f.type]
        tmp = f"_{f.name}_raw"
        lines = [
            f"{prim.cpp_type} {tmp}{{}};",
            f"s = reader.{prim.read_method}({tmp});",
            "if (!s) return s;",
        ]
        for b in f.bits:
            mask = (1 << b.width) - 1
            member_type = _bitfield_member_type(b, proto)
            if b.enum_type and b.enum_type in proto.enum_map:
                enum_def = proto.enum_map[b.enum_type]
                raw_expr = f"({tmp} >> {b.offset}) & 0x{mask:X}"
                lines.append(_enum_switch(b.name, raw_expr, enum_def))
            elif member_type == "bool":
                lines.append(
                    f"{b.name} = (({tmp} >> {b.offset}) & 0x{mask:X}) != 0;"
                )
            else:
                lines.append(
                    f"{b.name} = static_cast<{member_type}>"
                    f"(({tmp} >> {b.offset}) & 0x{mask:X});"
                )
        return "\n".join(lines)

    if f.kind == TypeKind.BYTES:
        return (
            f"s = reader.read_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRING:
        return (
            f"s = reader.read_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ARRAY:
        elem_type = f.element_type or "uint8_t"
        if elem_type in PRIMITIVES:
            prim = PRIMITIVES[elem_type]
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    s = reader.{prim.read_method}(elem);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        elif elem_type in proto.enum_map:
            enum_def = proto.enum_map[elem_type]
            prim = PRIMITIVES[enum_def.underlying_type]
            switch_code = _enum_switch("elem", "_tmp", enum_def)
            switch_lines = "\n".join("    " + l for l in switch_code.split("\n"))
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    {prim.cpp_type} _tmp{{}};\n"
                f"    s = reader.{prim.read_method}(_tmp);\n"
                f"    if (!s) return s;\n"
                f"{switch_lines}\n"
                f"}}"
            )
        else:
            # Nested struct array
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    s = elem.parse(reader);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )

    return f"// TODO: unsupported field kind {f.kind} for '{f.name}'"


def render_serialize_field(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    """Return indented C++ code to serialize one field."""
    code = _render_serialize_field_inner(f, proto, struct)
    code = _wrap_condition(code, f.condition)
    return _indent(code)


def _render_serialize_field_inner(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    if f.kind == TypeKind.PADDING:
        return f"s = writer.skip({f.pad_size});\nif (!s) return s;"

    if f.kind == TypeKind.PRIMITIVE:
        prim = PRIMITIVES[f.type]
        return (
            f"s = writer.{prim.write_method}({f.name});\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ENUM:
        enum_def = proto.enum_map[f.type]
        prim = PRIMITIVES[enum_def.underlying_type]
        return (
            f"s = writer.{prim.write_method}("
            f"static_cast<{prim.cpp_type}>({f.name}));\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRUCT:
        return f"s = {f.name}.serialize(writer);\nif (!s) return s;"

    if f.kind == TypeKind.BITFIELD:
        prim = BITFIELD_TYPES[f.type]
        tmp = f"_{f.name}_raw"
        lines = [f"{prim.cpp_type} {tmp}{{}};"]
        for b in f.bits:
            mask = (1 << b.width) - 1
            lines.append(
                f"{tmp} |= static_cast<{prim.cpp_type}>"
                f"((static_cast<{prim.cpp_type}>({b.name}) & 0x{mask:X}) << {b.offset});"
            )
        lines.append(f"s = writer.{prim.write_method}({tmp});")
        lines.append("if (!s) return s;")
        return "\n".join(lines)

    if f.kind == TypeKind.BYTES:
        return (
            f"s = writer.write_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRING:
        return (
            f"s = writer.write_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ARRAY:
        elem_type = f.element_type or "uint8_t"
        if elem_type in PRIMITIVES:
            prim = PRIMITIVES[elem_type]
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = writer.{prim.write_method}(elem);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        elif elem_type in proto.enum_map:
            enum_def = proto.enum_map[elem_type]
            prim = PRIMITIVES[enum_def.underlying_type]
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = writer.{prim.write_method}("
                f"static_cast<{prim.cpp_type}>(elem));\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        else:
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = elem.serialize(writer);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )

    return f"// TODO: unsupported field kind {f.kind} for '{f.name}'"


# ---------------------------------------------------------------------------
# Main generation entry point
# ---------------------------------------------------------------------------

def _make_guard(proto: ProtocolDef, suffix: str) -> str:
    """Build a header-guard name like ``NS_NAME_SUFFIX_``."""
    guard = proto.name.upper() + "_" + suffix.upper() + "_"
    if proto.namespace:
        guard = proto.namespace.upper().replace("::", "_") + "_" + guard
    return guard


def generate_io_header(proto: ProtocolDef) -> str:
    """Render the self-contained I/O primitives header for *proto*."""
    io_guard = _make_guard(proto, "IO_HPP")

    env = Environment(loader=BaseLoader(), keep_trailing_newline=True)
    env.globals.update(
        namespace=proto.namespace,
        io_guard=io_guard,
    )
    template = env.from_string(IO_TEMPLATE)
    return template.render()


def generate_header(proto: ProtocolDef, source_file: str = "<unknown>",
                    io_filename: str = "") -> str:
    """Render a complete C++ protocol header for *proto*."""
    guard_name = _make_guard(proto, "PROTOCOL_HPP")

    env = Environment(loader=BaseLoader(), keep_trailing_newline=True)
    env.globals.update(
        TypeKind=TypeKind,
        proto=proto,
        source_file=source_file,
        guard=guard_name,
        io_include=io_filename,
        hex_literal=_hex_literal,
        cpp_type=_cpp_type,
        bitfield_member_type=_bitfield_member_type,
        render_parse_field=render_parse_field,
        render_serialize_field=render_serialize_field,
    )
    template = env.from_string(HEADER_TEMPLATE)
    return template.render()


def _to_snake_case(name: str) -> str:
    """Convert PascalCase / camelCase to snake_case."""
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return s.lower()


def generate_to_file(
    proto: ProtocolDef,
    output_dir: pathlib.Path,
    source_file: str = "<unknown>",
) -> List[pathlib.Path]:
    """Generate io + protocol headers for *proto* into *output_dir*.

    Returns the list of paths written (io header, protocol header).
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    base = _to_snake_case(proto.name)

    io_filename = base + "_io.hpp"
    proto_filename = base + "_protocol.hpp"

    io_path = output_dir / io_filename
    io_content = generate_io_header(proto)
    io_path.write_text(io_content, encoding="utf-8")

    proto_path = output_dir / proto_filename
    proto_content = generate_header(proto, source_file=source_file,
                                    io_filename=io_filename)
    proto_path.write_text(proto_content, encoding="utf-8")

    return [io_path, proto_path]
