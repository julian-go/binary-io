"""C++17 code generation using Jinja2 templates."""

from __future__ import annotations

import pathlib
import re
from typing import Any, Dict

from jinja2 import Environment, BaseLoader

from .types import (
    BITFIELD_TYPES,
    PRIMITIVES,
    BitDef,
    EnumDef,
    FieldDef,
    ProtocolDef,
    StructDef,
    TypeKind,
)


# ---------------------------------------------------------------------------
# Jinja2 helpers exposed as template filters / globals
# ---------------------------------------------------------------------------

def _cpp_type(type_name: str, proto: ProtocolDef) -> str:
    """Map a YAML type name to its C++ type string."""
    if type_name in PRIMITIVES:
        return PRIMITIVES[type_name].cpp_type
    if type_name in proto.enum_map:
        return type_name
    if type_name in proto.struct_map:
        return type_name
    return type_name


def _hex_literal(value: int) -> str:
    """Format an integer as a C++ hex literal."""
    if value < 0:
        return str(value)
    return f"0x{value:X}"


def _format_expected(value: Any) -> str:
    """Format an expected-value constant for C++."""
    if isinstance(value, int):
        return _hex_literal(value)
    return str(value)


def _bitfield_member_type(b: BitDef, proto: ProtocolDef | None = None) -> str:
    """Return the C++ type for an individual bitfield member.

    If the bit-slice references an enum (via ``enum_type``), return the enum
    name.  Otherwise choose the smallest unsigned type that fits *width*
    (``bool`` for 1-bit fields).
    """
    if b.enum_type and proto and b.enum_type in proto.enum_map:
        return b.enum_type
    if b.width == 1:
        return "bool"
    if b.width <= 8:
        return "uint8_t"
    if b.width <= 16:
        return "uint16_t"
    return "uint32_t"


# ---------------------------------------------------------------------------
# Template strings
# ---------------------------------------------------------------------------

HEADER_TEMPLATE = r"""// =============================================================================
// Auto-generated by bio-gen from {{ source_file }}
// DO NOT EDIT â€” changes will be overwritten.
// =============================================================================

#ifndef {{ guard }}
#define {{ guard }}

#include <array>
#include <cstddef>
#include <cstdint>
#include <cstring>

#include "binary-io/binary-io.hpp"
{%- for inc in proto.includes %}
#include "{{ inc }}"
{%- endfor %}
{% if proto.namespace %}
namespace {{ proto.namespace }} {
{% endif %}
// ---------------------------------------------------------------------------
// Forward declarations
// ---------------------------------------------------------------------------
{%- for s in proto.structs %}
struct {{ s.name }};
{%- endfor %}

// ---------------------------------------------------------------------------
// Enumerations
// ---------------------------------------------------------------------------
{% for enum in proto.enums %}
{%- if enum.description %}
/// {{ enum.description }}
{%- endif %}
enum class {{ enum.name }} : {{ enum.cpp_underlying }} {
{%- for v in enum.values %}
{%- if v.description %}
    /// {{ v.description }}
{%- endif %}
    {{ v.name }} = {{ hex_literal(v.value) }},
{%- endfor %}
};
{% endfor %}

// ---------------------------------------------------------------------------
// Structs
// ---------------------------------------------------------------------------
{% for s in proto.structs %}
{%- if s.description %}
/// {{ s.description }}
{%- endif %}
struct {{ s.name }} {
{%- for f in s.fields %}
{%- if f.kind == TypeKind.PADDING %}
    // {{ f.name }}: {{ f.pad_size }} byte(s) padding (not stored)
{%- elif f.kind == TypeKind.BITFIELD %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
{%- for b in f.bits %}
{%- if b.description %}
    /// {{ b.description }}
{%- endif %}
    {{ bitfield_member_type(b, proto) }} {{ b.name }}{};
{%- endfor %}
{%- elif f.kind == TypeKind.BYTES %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<uint8_t, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.STRING %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<char, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.ARRAY %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    std::array<{{ cpp_type(f.element_type, proto) }}, {{ f.length }}> {{ f.name }}{};
{%- elif f.kind == TypeKind.ENUM %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ f.type }} {{ f.name }}{};
{%- elif f.kind == TypeKind.STRUCT %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ f.type }} {{ f.name }}{};
{%- else %}
{%- if f.description %}
    /// {{ f.description }}
{%- endif %}
    {{ cpp_type(f.type, proto) }} {{ f.name }}{};
{%- endif %}
{%- endfor %}

    /// Parse this struct from a binary reader.
    /// @return bio::Status::Ok() on success.
    bio::Status parse(bio::{{ proto.reader_alias }}& reader) {
        bio::Status s = bio::Status::Ok();
{% for f in s.fields %}
{{ render_parse_field(f, proto, s) }}
{% endfor %}
        return bio::Status::Ok();
    }

    /// Serialize this struct into a binary writer.
    /// @return bio::Status::Ok() on success.
    bio::Status serialize(bio::{{ proto.writer_alias }}& writer) const {
        bio::Status s = bio::Status::Ok();
{% for f in s.fields %}
{{ render_serialize_field(f, proto, s) }}
{% endfor %}
        return bio::Status::Ok();
    }
};
{% endfor %}
{%- if proto.namespace %}

}  // namespace {{ proto.namespace }}
{%- endif %}

#endif  // {{ guard }}
"""


# ---------------------------------------------------------------------------
# Field-level code-generation helpers
# ---------------------------------------------------------------------------

def _indent(code: str, level: int = 2) -> str:
    """Indent every line of *code* by *level* groups of 4 spaces."""
    prefix = "    " * level
    lines = code.rstrip("\n").split("\n")
    return "\n".join(prefix + line if line.strip() else "" for line in lines)


def _enum_switch(target: str, raw_expr: str, enum_def: EnumDef) -> str:
    """Generate a switch statement that safely converts a raw integer to an enum.

    Uses the first declared value as the ``default`` to avoid UB from
    ``static_cast`` with an out-of-range value.
    """
    lines = [f"switch ({raw_expr}) {{"]
    for v in enum_def.values:
        lines.append(
            f"    case {_hex_literal(v.value)}: "
            f"{target} = {enum_def.name}::{v.name}; break;"
        )
    default_val = enum_def.values[0]
    lines.append(
        f"    default: {target} = {enum_def.name}::{default_val.name}; break;"
    )
    lines.append("}")
    return "\n".join(lines)


def _wrap_condition(code: str, condition: str | None) -> str:
    if condition:
        inner = "\n".join("    " + line for line in code.split("\n"))
        return f"if ({condition}) {{\n{inner}\n}}"
    return code


def render_parse_field(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    """Return indented C++ code to parse one field."""
    code = _render_parse_field_inner(f, proto, struct)
    code = _wrap_condition(code, f.condition)
    return _indent(code)


def _render_parse_field_inner(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    if f.kind == TypeKind.PADDING:
        return f"s = reader.skip({f.pad_size});\nif (!s) return s;"

    if f.kind == TypeKind.PRIMITIVE:
        prim = PRIMITIVES[f.type]
        lines = [
            f"s = reader.{prim.read_method}({f.name});",
            "if (!s) return s;",
        ]
        if f.expected is not None:
            lines.append(
                f"if ({f.name} != {_format_expected(f.expected)}) "
                f"return bio::Status::OutOfRange();"
            )
        return "\n".join(lines)

    if f.kind == TypeKind.ENUM:
        enum_def = proto.enum_map[f.type]
        prim = PRIMITIVES[enum_def.underlying_type]
        tmp = f"_{f.name}_raw"
        lines = [
            f"{prim.cpp_type} {tmp}{{}};",
            f"s = reader.{prim.read_method}({tmp});",
            "if (!s) return s;",
        ]
        lines.append(_enum_switch(f.name, tmp, enum_def))
        if f.expected is not None:
            lines.append(
                f"if ({tmp} != {_format_expected(f.expected)}) "
                f"return bio::Status::OutOfRange();"
            )
        return "\n".join(lines)

    if f.kind == TypeKind.STRUCT:
        return f"s = {f.name}.parse(reader);\nif (!s) return s;"

    if f.kind == TypeKind.BITFIELD:
        prim = BITFIELD_TYPES[f.type]
        tmp = f"_{f.name}_raw"
        lines = [
            f"{prim.cpp_type} {tmp}{{}};",
            f"s = reader.{prim.read_method}({tmp});",
            "if (!s) return s;",
        ]
        for b in f.bits:
            mask = (1 << b.width) - 1
            member_type = _bitfield_member_type(b, proto)
            if b.enum_type and b.enum_type in proto.enum_map:
                enum_def = proto.enum_map[b.enum_type]
                raw_expr = f"({tmp} >> {b.offset}) & 0x{mask:X}"
                lines.append(_enum_switch(b.name, raw_expr, enum_def))
            elif member_type == "bool":
                lines.append(
                    f"{b.name} = (({tmp} >> {b.offset}) & 0x{mask:X}) != 0;"
                )
            else:
                lines.append(
                    f"{b.name} = static_cast<{member_type}>"
                    f"(({tmp} >> {b.offset}) & 0x{mask:X});"
                )
        return "\n".join(lines)

    if f.kind == TypeKind.BYTES:
        return (
            f"s = reader.read_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRING:
        return (
            f"s = reader.read_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ARRAY:
        elem_type = f.element_type or "uint8_t"
        if elem_type in PRIMITIVES:
            prim = PRIMITIVES[elem_type]
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    s = reader.{prim.read_method}(elem);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        elif elem_type in proto.enum_map:
            enum_def = proto.enum_map[elem_type]
            prim = PRIMITIVES[enum_def.underlying_type]
            switch_code = _enum_switch("elem", "_tmp", enum_def)
            switch_lines = "\n".join("    " + l for l in switch_code.split("\n"))
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    {prim.cpp_type} _tmp{{}};\n"
                f"    s = reader.{prim.read_method}(_tmp);\n"
                f"    if (!s) return s;\n"
                f"{switch_lines}\n"
                f"}}"
            )
        else:
            # Nested struct array
            return (
                f"for (auto& elem : {f.name}) {{\n"
                f"    s = elem.parse(reader);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )

    return f"// TODO: unsupported field kind {f.kind} for '{f.name}'"


def render_serialize_field(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    """Return indented C++ code to serialize one field."""
    code = _render_serialize_field_inner(f, proto, struct)
    code = _wrap_condition(code, f.condition)
    return _indent(code)


def _render_serialize_field_inner(f: FieldDef, proto: ProtocolDef, struct: StructDef) -> str:
    if f.kind == TypeKind.PADDING:
        return f"s = writer.skip({f.pad_size});\nif (!s) return s;"

    if f.kind == TypeKind.PRIMITIVE:
        prim = PRIMITIVES[f.type]
        return (
            f"s = writer.{prim.write_method}({f.name});\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ENUM:
        enum_def = proto.enum_map[f.type]
        prim = PRIMITIVES[enum_def.underlying_type]
        return (
            f"s = writer.{prim.write_method}("
            f"static_cast<{prim.cpp_type}>({f.name}));\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRUCT:
        return f"s = {f.name}.serialize(writer);\nif (!s) return s;"

    if f.kind == TypeKind.BITFIELD:
        prim = BITFIELD_TYPES[f.type]
        tmp = f"_{f.name}_raw"
        lines = [f"{prim.cpp_type} {tmp}{{}};"]
        for b in f.bits:
            mask = (1 << b.width) - 1
            lines.append(
                f"{tmp} |= static_cast<{prim.cpp_type}>"
                f"((static_cast<{prim.cpp_type}>({b.name}) & 0x{mask:X}) << {b.offset});"
            )
        lines.append(f"s = writer.{prim.write_method}({tmp});")
        lines.append("if (!s) return s;")
        return "\n".join(lines)

    if f.kind == TypeKind.BYTES:
        return (
            f"s = writer.write_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.STRING:
        return (
            f"s = writer.write_bytes({f.name}.data(), {f.name}.size());\n"
            f"if (!s) return s;"
        )

    if f.kind == TypeKind.ARRAY:
        elem_type = f.element_type or "uint8_t"
        if elem_type in PRIMITIVES:
            prim = PRIMITIVES[elem_type]
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = writer.{prim.write_method}(elem);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        elif elem_type in proto.enum_map:
            enum_def = proto.enum_map[elem_type]
            prim = PRIMITIVES[enum_def.underlying_type]
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = writer.{prim.write_method}("
                f"static_cast<{prim.cpp_type}>(elem));\n"
                f"    if (!s) return s;\n"
                f"}}"
            )
        else:
            return (
                f"for (const auto& elem : {f.name}) {{\n"
                f"    s = elem.serialize(writer);\n"
                f"    if (!s) return s;\n"
                f"}}"
            )

    return f"// TODO: unsupported field kind {f.kind} for '{f.name}'"


# ---------------------------------------------------------------------------
# Main generation entry point
# ---------------------------------------------------------------------------

def generate_header(proto: ProtocolDef, source_file: str = "<unknown>") -> str:
    """Render a complete C++ header for *proto*."""
    guard_name = proto.name.upper() + "_PROTOCOL_HPP_"
    if proto.namespace:
        guard_name = proto.namespace.upper().replace("::", "_") + "_" + guard_name

    env = Environment(loader=BaseLoader(), keep_trailing_newline=True)
    env.globals.update(
        TypeKind=TypeKind,
        proto=proto,
        source_file=source_file,
        guard=guard_name,
        hex_literal=_hex_literal,
        cpp_type=_cpp_type,
        bitfield_member_type=_bitfield_member_type,
        render_parse_field=render_parse_field,
        render_serialize_field=render_serialize_field,
    )
    template = env.from_string(HEADER_TEMPLATE)
    return template.render()


def _to_snake_case(name: str) -> str:
    """Convert PascalCase / camelCase to snake_case."""
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s)
    return s.lower()


def generate_to_file(
    proto: ProtocolDef,
    output_dir: pathlib.Path,
    source_file: str = "<unknown>",
) -> pathlib.Path:
    """Generate a header file for *proto* into *output_dir*. Returns the path."""
    output_dir.mkdir(parents=True, exist_ok=True)
    filename = _to_snake_case(proto.name) + "_protocol.hpp"
    out_path = output_dir / filename
    content = generate_header(proto, source_file=source_file)
    out_path.write_text(content, encoding="utf-8")
    return out_path
